/**
 * @author Zhihang Yao
 * @classDescription Worker to dispatch and manage the visibly of the kml netowkrlink layers
 * @requires Master json file generated by 3DCityDB KML/COLLADA Exporter (Cesium Branch) 
 */
(function() {
	var shouldRun = false;
	var stack = [];
	var isStillUpdating = true;
	var rTree;
	
	var _bbox;
	var _rowDelta;
	var _colDelta;
	var _rownum;
	var _colnum;
	var _maxCountOfVisibleTiles;
	var _maxNumberOfConcurrentXhrs;
	
	var eventlisteners = {
		initWorker : function(frame, maxCountOfVisibleTiles, maxNumberOfConcurrentXhrs, mode) {
			shouldRun = true;
			_maxCountOfVisibleTiles = maxCountOfVisibleTiles;
			_maxNumberOfConcurrentXhrs = maxNumberOfConcurrentXhrs;
			console.log([frame, mode]);
			eventlisteners["checkDataPool"].apply(self, [ frame, mode ]);
		},
	
		checkDataPool : function(frame, mode) {
			if (shouldRun == false) 
				return;
			
			var dataPool = [];
			if (mode == 'matrix') {
				dataPool = eventlisteners["queryByMatrix"].apply(self, [ frame ]);	
			}
			else {
				dataPool = eventlisteners["queryByRTree"].apply(self, [ frame ]);	
			}

			console.log("Size of the generated datapool is: " + dataPool.length);
			if (dataPool.length == 0 || dataPool.length > _maxCountOfVisibleTiles) {
				stack = [];
				eventlisteners["updateTaskStack"].apply(self);
				return;
			}
				
			// Tiles within the view frame are sorted, so that the tiles in the middle of the viewport will be loaded firstly
			stack = eventlisteners["sortDatapool"].apply(self, [ dataPool, frame ]).reverse();
	
			for (var i = 0; i < _maxNumberOfConcurrentXhrs; i++) {
				setTimeout(function(){
					if (stack != null) {
						var matrixItem = stack.pop();
						if (typeof matrixItem != 'undefined') {
							reply("checkMasterPool", matrixItem);
						}						
					}					
				},i*5);					
			}
		},
	
		updateDataPoolRecord : function() {
			isStillUpdating = true;
		},
	
		notifySleep : function() {
			shouldRun = false;
		},
	
		notifyWake : function() {
			shouldRun = true;
			reply("removeDatasources");
		},
	
		abortAndnotifyWake : function() {
			stack = null;
			eventlisteners["notifyWake"].apply(self);
		},
	
		createMatrix : function(bbox, rowDelta, colDelta, rownum, colnum) {
			_bbox = bbox;
			_rowDelta = rowDelta;
			_colDelta = colDelta;
			_rownum = rownum;
			_colnum = colnum;
		},
		
		calculatePixels: function(polygon1, polygon2, funcId) {
			var intersectPolygon = intersectionPolygons(polygon1, polygon2);
        	var area = 0;         
			var j = intersectPolygon.length - 1;  
			for (var i=0; i<intersectPolygon.length; i++){
				area = area +  (intersectPolygon[j].x + intersectPolygon[i].x) * (intersectPolygon[j].y - intersectPolygon[i].y); 
		        j = i;  
		    }		
			setTimeout(function(){
				reply(funcId, Math.sqrt(area/2));
			},1);			
		},
		
		queryByMatrix : function(frame) {
			var dataPool = new Array();
			
			var frameMinX = frame[0];
			var frameMinY = frame[1];
			var frameMaxX = frame[2];
			var frameMaxY = frame[3];
			var minCol = Math.floor((frameMinX - _bbox.xmin) / _colDelta);
			var maxCol = Math.floor((frameMaxX - _bbox.xmin) / _colDelta);
			var minRow = Math.floor((frameMinY - _bbox.ymin) / _rowDelta);
			var maxRow = Math.floor((frameMaxY - _bbox.ymin) / _rowDelta);
			
			/** i --> column (X); j --> row (Y) */	
			if ((maxCol - minCol) * (maxRow - minRow) > _maxCountOfVisibleTiles) {
				for (var k = 0; k <= _maxCountOfVisibleTiles; k++ ) {
					dataPool.push("dummy");
				}
			}
			else {							
				for ( var i = minCol; i <= maxCol; i++ ) {
					if (i >= 0 && i <= _colnum) {
						for ( var j = minRow; j <= maxRow; j++ ) {
							if (j >= 0 && j <= _rownum) {
								var minX = _bbox.xmin + i * _colDelta;
								var minY = _bbox.ymin + j * _rowDelta;
								var maxX = _bbox.xmin + (i + 1) * _colDelta;
								var maxY = _bbox.ymin + (j + 1) * _rowDelta;
								dataPool.push([ minX, minY, maxX, maxY, {col: i, row: j}]);	
							}														
						}
					}				
				}	
			}			
			return dataPool;
		},
		
		createRTree : function(treeSize) {
			rTree = rbush(treeSize);
		},

		addItemToRTree : function(item) {
			rTree.insert(item);
		},		
		
		queryByRTree: function(frame) {
			return rTree.search(frame);
		},
	
		sortDatapool : function(pool, frame) {
			var centerX = (frame[0] + frame[2]) / 2;
			var centerY = (frame[1] + frame[3]) / 2;
			pool.sort(function(a, b) {
				var ax = (a[0] + a[2]) / 2;
				var ay = (a[1] + a[3]) / 2;
				var as = Math.sqrt((centerX - ax) * (centerX - ax) + (centerY - ay) * (centerY - ay));
	
				var bx = (b[0] + b[2]) / 2;
				var by = (b[1] + b[3]) / 2;
				var bs = Math.sqrt((centerX - bx) * (centerX - bx) + (centerY - by) * (centerY - by));
	
				return as - bs;
			});
	
			return pool;
		},

		updateTaskStack : function() {	
			if (stack == null) {
				return;
			}				
	
			var matrixItem = stack.pop();
			if (typeof matrixItem == 'undefined') {
				if (isStillUpdating) {
					isStillUpdating = false;
					reply("removeDatasources");
					console.log("Tiling Manager repeat searching again...");
				} else {
					if (shouldRun == true) {
						shouldRun = false;
						console.log("Tiling Manager is sleeping...");
						reply("refreshView");
					}
				}
			} else {
				reply("checkMasterPool", matrixItem);
			}      										        							        			
		}
	};
	
	//---------------------- system functions -----------------------------//			
	
	function defaultListener(vMsg) {}	
	/** listener name, argument to pass 1, argument to pass 2, etc. etc **/
	function reply() {
		if (arguments.length < 1) {
			throw new TypeError("reply - not enough arguments");
			return;
		}
		postMessage({
			"vo42t30" : arguments[0],
			"rnb93qh" : Array.prototype.slice.call(arguments, 1)
		});
	}
	
	self.onmessage = function(oEvent) {
		if (oEvent.data instanceof Object && oEvent.data.hasOwnProperty("bk4e1h0") && oEvent.data.hasOwnProperty("ktp3fm1")) {
			eventlisteners[oEvent.data.bk4e1h0].apply(self, oEvent.data.ktp3fm1);
		} else {
			defaultListener(oEvent.data);
		}
	};
})();


/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++**/	
	/**
	 (c) 2013, Vladimir Agafonkin
	 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
	 https://github.com/mourner/rbush
	*/

	(function () { 'use strict';

	function rbush(maxEntries, format) {

	    // jshint newcap: false, validthis: true
	    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

	    if (format) {
	        this._initFormat(format);
	    }

	    this.clear();
	}

	rbush.prototype = {

	    all: function () {
	        return this._all(this.data, []);
	    },

	    search: function (bbox) {

	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;

	        if (!intersects(bbox, node.bbox)) return result;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child.bbox;

	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);
	                    else if (contains(bbox, childBBox)) this._all(child, result);
	                    else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return result;
	    },

	    load: function (data) {
	        if (!(data && data.length)) return this;

	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }

	        // recursively build the tree with the given data from stratch using OMT algorithm
	        var node = this._build(data.slice(), 0, data.length - 1, 0);

	        if (!this.data.children.length) {
	            // save as is if tree is empty
	            this.data = node;

	        } else if (this.data.height === node.height) {
	            // split root if trees have the same height
	            this._splitRoot(this.data, node);

	        } else {
	            if (this.data.height < node.height) {
	                // swap trees if inserted one is bigger
	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }

	            // insert the small tree into the large tree at appropriate level
	            this._insert(node, this.data.height - node.height - 1, true);
	        }

	        return this;
	    },

	    insert: function (item) {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },

	    clear: function () {
	        this.data = {
	            children: [],
	            height: 1,
	            bbox: empty(),
	            leaf: true
	        };
	        return this;
	    },

	    remove: function (item) {
	        if (!item) return this;

	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i, parent, index, goingUp;

	        // depth-first iterative tree traversal
	        while (node || path.length) {

	            if (!node) { // go up
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }

	            if (node.leaf) { // check current node
	                index = node.children.indexOf(item);

	                if (index !== -1) {
	                    // item found, remove the item and condense tree upwards
	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }

	            if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];

	            } else if (parent) { // go right
	                i++;
	                node = parent.children[i];
	                goingUp = false;

	            } else node = null; // nothing found
	        }

	        return this;
	    },

	    toBBox: function (item) { return item; },

	    compareMinX: function (a, b) { return a[0] - b[0]; },
	    compareMinY: function (a, b) { return a[1] - b[1]; },

	    toJSON: function () { return this.data; },

	    fromJSON: function (data) {
	        this.data = data;
	        return this;
	    },

	    _all: function (node, result) {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);
	            else nodesToSearch.push.apply(nodesToSearch, node.children);

	            node = nodesToSearch.pop();
	        }
	        return result;
	    },

	    _build: function (items, left, right, height) {

	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;

	        if (N <= M) {
	            // reached leaf level; return leaf
	            node = {
	                children: items.slice(left, right + 1),
	                height: 1,
	                bbox: null,
	                leaf: true
	            };
	            calcBBox(node, this.toBBox);
	            return node;
	        }

	        if (!height) {
	            // target height of the bulk-loaded tree
	            height = Math.ceil(Math.log(N) / Math.log(M));

	            // target number of root entries to maximize storage utilization
	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }

	        // TODO eliminate recursion?

	        node = {
	            children: [],
	            height: height,
	            bbox: null
	        };

	        // split the items into M mostly square tiles

	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i, j, right2, right3;

	        multiSelect(items, left, right, N1, this.compareMinX);

	        for (i = left; i <= right; i += N1) {

	            right2 = Math.min(i + N1 - 1, right);

	            multiSelect(items, i, right2, N2, this.compareMinY);

	            for (j = i; j <= right2; j += N2) {

	                right3 = Math.min(j + N2 - 1, right2);

	                // pack each entry recursively
	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }

	        calcBBox(node, this.toBBox);

	        return node;
	    },

	    _chooseSubtree: function (bbox, node, level, path) {

	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

	        while (true) {
	            path.push(node);

	            if (node.leaf || path.length - 1 === level) break;

	            minArea = minEnlargement = Infinity;

	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea(child.bbox);
	                enlargement = enlargedArea(bbox, child.bbox) - area;

	                // choose entry with the least area enlargement
	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;

	                } else if (enlargement === minEnlargement) {
	                    // otherwise choose one with the smallest area
	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }

	            node = targetNode;
	        }

	        return node;
	    },

	    _insert: function (item, level, isNode) {

	        var toBBox = this.toBBox,
	            bbox = isNode ? item.bbox : toBBox(item),
	            insertPath = [];

	        // find the best node for accommodating the item, saving all nodes along the path too
	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

	        // put the item into the node
	        node.children.push(item);
	        extend(node.bbox, bbox);

	        // split on node overflow; propagate upwards if necessary
	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }

	        // adjust bboxes along the insertion path
	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },

	    // split overflowed node into two
	    _split: function (insertPath, level) {

	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;

	        this._chooseSplitAxis(node, m, M);

	        var newNode = {
	            children: node.children.splice(this._chooseSplitIndex(node, m, M)),
	            height: node.height
	        };

	        if (node.leaf) newNode.leaf = true;

	        calcBBox(node, this.toBBox);
	        calcBBox(newNode, this.toBBox);

	        if (level) insertPath[level - 1].children.push(newNode);
	        else this._splitRoot(node, newNode);
	    },

	    _splitRoot: function (node, newNode) {
	        // split root node
	        this.data = {
	            children: [node, newNode],
	            height: node.height + 1
	        };
	        calcBBox(this.data, this.toBBox);
	    },

	    _chooseSplitIndex: function (node, m, M) {

	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

	        minOverlap = minArea = Infinity;

	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox(node, 0, i, this.toBBox);
	            bbox2 = distBBox(node, i, M, this.toBBox);

	            overlap = intersectionArea(bbox1, bbox2);
	            area = bboxArea(bbox1) + bboxArea(bbox2);

	            // choose distribution with minimum overlap
	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;

	                minArea = area < minArea ? area : minArea;

	            } else if (overlap === minOverlap) {
	                // otherwise choose distribution with minimum area
	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }

	        return index;
	    },

	    // sorts node children by the best axis for split
	    _chooseSplitAxis: function (node, m, M) {

	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);

	        // if total distributions margin value is minimal for x, sort by minX,
	        // otherwise it's already sorted by minY
	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },

	    // total margin of all possible split distributions where each node is at least m full
	    _allDistMargin: function (node, m, M, compare) {

	        node.children.sort(compare);

	        var toBBox = this.toBBox,
	            leftBBox = distBBox(node, 0, m, toBBox),
	            rightBBox = distBBox(node, M - m, M, toBBox),
	            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
	            i, child;

	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
	            margin += bboxMargin(leftBBox);
	        }

	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
	            margin += bboxMargin(rightBBox);
	        }

	        return margin;
	    },

	    _adjustParentBBoxes: function (bbox, path, level) {
	        // adjust bboxes along the given tree path
	        for (var i = level; i >= 0; i--) {
	            extend(path[i].bbox, bbox);
	        }
	    },

	    _condense: function (path) {
	        // go through the path, removing empty nodes and updating bboxes
	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);

	                } else this.clear();

	            } else calcBBox(path[i], this.toBBox);
	        }
	    },

	    _initFormat: function (format) {
	        // data format (minX, minY, maxX, maxY accessors)

	        // uses eval-type function compilation instead of just accepting a toBBox function
	        // because the algorithms are very sensitive to sorting functions performance,
	        // so they should be dead simple and without inner calls

	        // jshint evil: true

	        var compareArr = ['return a', ' - b', ';'];

	        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
	        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

	        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
	    }
	};


	// calculate node's bbox from bboxes of its children
	function calcBBox(node, toBBox) {
	    node.bbox = distBBox(node, 0, node.children.length, toBBox);
	}

	// min bounding rectangle of node children from k to p-1
	function distBBox(node, k, p, toBBox) {
	    var bbox = empty();

	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
	    }

	    return bbox;
	}

	function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }

	function extend(a, b) {
	    a[0] = Math.min(a[0], b[0]);
	    a[1] = Math.min(a[1], b[1]);
	    a[2] = Math.max(a[2], b[2]);
	    a[3] = Math.max(a[3], b[3]);
	    return a;
	}

	function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
	function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

	function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
	function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

	function enlargedArea(a, b) {
	    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
	           (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
	}

	function intersectionArea(a, b) {
	    var minX = Math.max(a[0], b[0]),
	        minY = Math.max(a[1], b[1]),
	        maxX = Math.min(a[2], b[2]),
	        maxY = Math.min(a[3], b[3]);

	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}

	function contains(a, b) {
	    return a[0] <= b[0] &&
	           a[1] <= b[1] &&
	           b[2] <= a[2] &&
	           b[3] <= a[3];
	}

	function intersects(a, b) {
	    return b[0] <= a[2] &&
	           b[1] <= a[3] &&
	           b[2] >= a[0] &&
	           b[3] >= a[1];
	}

	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach

	function multiSelect(arr, left, right, n, compare) {
	    var stack = [left, right],
	        mid;

	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();

	        if (right - left <= n) continue;

	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        select(arr, left, right, mid, compare);

	        stack.push(left, mid, mid, right);
	    }
	}

	// sort array between left and right (inclusive) so that the smallest k elements come first (unordered)
	function select(arr, left, right, k, compare) {
	    var n, i, z, s, sd, newLeft, newRight, t, j;

	    while (right > left) {
	        if (right - left > 600) {
	            n = right - left + 1;
	            i = k - left + 1;
	            z = Math.log(n);
	            s = 0.5 * Math.exp(2 * z / 3);
	            sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);
	            newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
	            newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
	            select(arr, newLeft, newRight, k, compare);
	        }

	        t = arr[k];
	        i = left;
	        j = right;

	        swap(arr, left, k);
	        if (compare(arr[right], t) > 0) swap(arr, left, right);

	        while (i < j) {
	            swap(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) i++;
	            while (compare(arr[j], t) > 0) j--;
	        }

	        if (compare(arr[left], t) === 0) swap(arr, left, j);
	        else {
	            j++;
	            swap(arr, j, right);
	        }

	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}

	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}


	// export as AMD/CommonJS module or global variable
	if (typeof define === 'function' && define.amd) define(function() { return rbush; });
	else if (typeof module !== 'undefined') module.exports = rbush;
	else if (typeof self !== 'undefined') self.rbush = rbush;
	else window.rbush = rbush;

	})();
	
	/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Polygon.js ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++**/
	
	// Author: Andrija Cajic, XEETech.com
	// Website: http://freshplayer.blogspot.de/2014/04/intersection-of-two-2d-polygons-in.html
	/* 
	Returns a new polygon (array of points) which represents an intersection of the two polygons that were passed as arguments.
	If intersection of two polygons results in multiple polygons, function only returns one of them.
	Supports concave polygons but does not support complex polygons (http://upload.wikimedia.org/wikipedia/commons/3/34/Complex_polygon.png).

	This implementation is similar to the one described by Margalit & Knott: "An algorithm for computing the union, intersection or difference 
	of two polygons" (http://gvu.gatech.edu/people/official/jarek/graphics/papers/04PolygonBooleansMargalit.pdf) Its complexity is O(n^2). 4*n1*n2,  
	to be more precise, where n1 is number of points in the first polygon, and n2 number of points in second polygon. With a few tweaks, the algorithm 
	could be optimized, but with the same general idea in place, it is impossible to get rid of n^2 complexity.
	*/
	
	function intersectionPolygons(polygon1, polygon2) {
	    polygon1 = clockwisePolygon(polygon1);
	    polygon2 = clockwisePolygon(polygon2);


	    var polygon1ExpandedDict = {};
	    var polygon2ExpandedDict = {};
	    for (var i = 0; i < polygon1.length; i++) {
	        var polygon1Line = [polygon1[i], polygon1[(i + 1) % polygon1.length]];
	        polygon1ExpandedDict[i] = [cloneObject(polygon1[i])];
	        for (var j = 0; j < polygon2.length; j++) {
	            if (i == 0)
	                polygon2ExpandedDict[j] = [cloneObject(polygon2[j])];

	            var polygon2Line = [polygon2[j], polygon2[(j + 1) % polygon2.length]];
	            var intersectionResult = intersectionLines(polygon1Line, polygon2Line);
	            

	            if (intersectionResult.onLine1 && intersectionResult.onLine2) {
	                if (pointsEqual(intersectionResult, polygon1[i])) {
	                    polygon1ExpandedDict[i][0].isCrossPoint = true;
	                    polygon1ExpandedDict[i][0].isOriginalPoint = true;
	                    polygon1ExpandedDict[i][0].crossingLine = polygon2Line;
	                } else if (pointsEqual(intersectionResult, polygon1[(i + 1) % polygon1.length])) {
	                    
	                } else {
	                    var newPolygon1Point = cloneObject(intersectionResult);
	                    newPolygon1Point.isCrossPoint = true;
	                    newPolygon1Point.crossingLine = polygon2Line;
	                    newPolygon1Point.distanceFromPreviousPoint = pointsDistance(polygon1[i], newPolygon1Point);
	                    var lastIndex = polygon1ExpandedDict[i].length - 1;
	                    while (polygon1ExpandedDict[i][lastIndex].distanceFromPreviousPoint && polygon1ExpandedDict[i][lastIndex].distanceFromPreviousPoint > newPolygon1Point.distanceFromPreviousPoint) {
	                        lastIndex--; // maybe current polygon1Line will be intersected in many places,
	                        // when intersection points are added to polygon1Expanded, they need to be properly sorted
	                    }
	                    if (!pointsEqual(polygon1ExpandedDict[i][lastIndex], newPolygon1Point) && !pointsEqual(polygon1ExpandedDict[i][lastIndex + 1], newPolygon1Point)) {
	                        polygon1ExpandedDict[i].splice(lastIndex + 1, 0, newPolygon1Point);
	                    }
	                }

	                if (pointsEqual(intersectionResult, polygon2[j])) {
	                    polygon2ExpandedDict[j][0].isCrossPoint = true;
	                    polygon2ExpandedDict[j][0].isOriginalPoint = true;
	                    polygon2ExpandedDict[j][0].crossingLine = polygon1Line;
	                } else if (pointsEqual(intersectionResult, polygon2[(j + 1) % polygon2.length])) {

	                } else {
	                    var newPolygon2Point = cloneObject(intersectionResult);
	                    newPolygon2Point.isCrossPoint = true;
	                    newPolygon2Point.crossingLine = polygon1Line;
	                    newPolygon2Point.distanceFromPreviousPoint = pointsDistance(polygon2[j], newPolygon2Point);
	                    lastIndex = polygon2ExpandedDict[j].length - 1;
	                    while (polygon2ExpandedDict[j][lastIndex].distanceFromPreviousPoint && polygon2ExpandedDict[j][lastIndex].distanceFromPreviousPoint > newPolygon2Point.distanceFromPreviousPoint) {
	                        lastIndex--;
	                    }
	                    if (!pointsEqual(polygon2ExpandedDict[j][lastIndex], newPolygon2Point) && !pointsEqual(polygon2ExpandedDict[j][lastIndex+1], newPolygon2Point)) {
	                        polygon2ExpandedDict[j].splice(lastIndex + 1, 0, newPolygon2Point);
	                    }
	                    
	                }
	            }
	        }
	    }
	    

	    var polygon1Expanded = [];
	    for (i = 0; i < polygon1.length; i++) {
	        for (j = 0; j < polygon1ExpandedDict[i].length; j++) {
	            var polygon1ExpandedPoint = polygon1ExpandedDict[i][j];
	            polygon1Expanded.push(polygon1ExpandedPoint);
	        }
	    }

	    var polygon2Expanded = [];
	    var startingPoint = null;
	    var currentPolygon = null;
	    var otherPolygon = null;
	    var currentIndex = null;
	    var currentPoint = null;
	    
	    var polygon2ExpandedIndex = null;
	    var index = 0;
	    for (i = 0; i < polygon2.length; i++) {
	        for (j = 0; j < polygon2ExpandedDict[i].length; j++) {
	            var polygon2ExpandedPoint = polygon2ExpandedDict[i][j];
	            polygon2Expanded.push(polygon2ExpandedPoint);
	            
	            if (startingPoint == null && polygon2ExpandedPoint.isCrossPoint) {
	                startingPoint = polygon2ExpandedPoint;
	                polygon2ExpandedIndex = index;
	            }
	            index++;
	        }
	    }
	    

	    if (startingPoint == null) {
	        // either polygons are separated, or one contains another <==> polygons' lines never intersect one another
	        var isPolygon2WithinPolygon1 = isPointInsidePolygon(polygon2[0], polygon1);
	        if (isPolygon2WithinPolygon1) {
	            startingPoint = polygon2Expanded[0];
	            currentPolygon = polygon2Expanded;
	            otherPolygon = polygon1Expanded;
	            currentIndex = 0;
	        } else {
	            var isPolygon1WithinPolygon2 = isPointInsidePolygon(polygon1[0], polygon2);
	            if (isPolygon1WithinPolygon2) {
	                startingPoint = polygon1Expanded[0];
	                currentPolygon = polygon1Expanded;
	                otherPolygon = polygon2Expanded;
	                currentIndex = 0;
	            } else {
	                // these two polygons are completely separated
	                return [];
	            }
	        }
	    } else {
	        currentPolygon = polygon2Expanded;
	        otherPolygon = polygon1Expanded;
	        currentIndex = polygon2ExpandedIndex;
	    }

	    var intersectingPolygon = [startingPoint];
	    
	    var switchPolygons = false;
	    if (startingPoint.isCrossPoint) {
	        var pointJustAfterStartingPoint = justAfterPointOfACrossPoint(currentIndex, currentPolygon);
	        if (isPointInsidePolygon(pointJustAfterStartingPoint, otherPolygon)) {
	            switchPolygons = false;
	        } else {
	            switchPolygons = true;
	        }
	    } else {
	        switchPolygons = false;
	    }

	    if (switchPolygons) {
	        var temp = currentPolygon;
	        currentPolygon = otherPolygon;
	        otherPolygon = temp;

	        currentIndex = indexElementMatchingFunction(currentPolygon, function (point) {
	            return pointsEqual(startingPoint, point);
	        });
	    } 
	    
	    currentPoint = currentPolygon[(currentIndex + 1) % currentPolygon.length];;
	    currentIndex = (currentIndex + 1) % currentPolygon.length;

	    
	    while (!pointsEqual(currentPoint, startingPoint)) {
	        intersectingPolygon.push(currentPoint);
	        if (currentPoint.isCrossPoint) {
	            if (currentPoint.crossingLine && currentPoint.isOriginalPoint) {
	                var pointJustBeforeCurrent = justBeforePointOfACrossPoint(currentIndex, currentPolygon);
	                var pointJustAfterCurrent = justAfterPointOfACrossPoint(currentIndex, currentPolygon);

	                var isBeforeLeft = isPointLeftOfLine(pointJustBeforeCurrent, currentPoint.crossingLine);
	                var isAfterLeft = isPointLeftOfLine(pointJustAfterCurrent, currentPoint.crossingLine);
	                if (isBeforeLeft == isAfterLeft) {
	                    // do not switch to different polygon
	                } else {
	                    var temp = currentPolygon;
	                    currentPolygon = otherPolygon;
	                    otherPolygon = temp;
	                }
	            } else {
	                var temp = currentPolygon;
	                currentPolygon = otherPolygon;
	                otherPolygon = temp;
	            }

	            currentIndex = indexElementMatchingFunction(currentPolygon, function(point) {
	                return pointsEqual(currentPoint, point);
	            });
	        }        

	        currentIndex = (currentIndex + 1) % currentPolygon.length;
	        currentPoint = currentPolygon[currentIndex];
	    }

	    return intersectingPolygon;
	}

	function justBeforePointOfACrossPoint(pointIndex, polygon) {
	    var point = polygon[pointIndex];
	    var previousIndex = (polygon.length + pointIndex - 1) % polygon.length;
	    var previousPoint = polygon[previousIndex];

	    var pointJustBeforeCurrent = {
	        x: (point.x + previousPoint.x) / 2,
	        y: (point.y + previousPoint.y) / 2
	    };

	    return pointJustBeforeCurrent;
	}

	function justAfterPointOfACrossPoint(pointIndex, polygon) {
	    var point = polygon[pointIndex];
	    var nextIndex = (pointIndex + 1) % polygon.length;
	    var nextPoint = polygon[nextIndex];

	    var pointJustAfterCurrent = {
	        x: (point.x + nextPoint.x) / 2,
	        y: (point.y + nextPoint.y) / 2
	    };

	    return pointJustAfterCurrent;
	}


	/**
	If the polygon that is passed as argument is clockwise, that polygon is returned. If it is counter-clockwise, a polygon with same points but in reversed order is returned.
	Complexity O(n)
	*/
	function clockwisePolygon(polygon) {
	    var sum = 0;
	    var filterDuplicates = [];
	    var reversedPolygon = [];
	    for (var i = 0; i < polygon.length; i++) {
	        var currentPoint = polygon[i];
	        var nextPoint = polygon[(i + 1) % polygon.length];
	        if (!pointsEqual(currentPoint, nextPoint)) {
	            filterDuplicates.push(currentPoint);
	            reversedPolygon.splice(0, 0, currentPoint);
	        }
	        sum += (nextPoint.x - currentPoint.x) * (nextPoint.y + currentPoint.y);
	    }
	    if (sum > 0) {
	        // polygon is clockwise
	        return polygon;
	    } else {
	        // polygon is counter-clockwise
	        return reversedPolygon;
	    }
	}


	/**
	Works for any polygon, not just convex polygons.
	@param bordersCountAsOutside - if point is exactly on the polygon's border, this parameter determines whether the point will be classified as 'inside' or 'outside'
	*/
	function isPointInsidePolygon(point, polygon, onBorderCountsAsOutside) {
	    // point is any javascript object that contains both x & y numeric parameters
	    // polygon is array of points, properly sorted to form a polygon
	    var pointVerticalLine = [point, { x: point.x, y: point.y + 1 }];
	    var higherIntersectionsCount = 0;
	    var lowerIntersectionCount = 0;
		for (var i = 0; i < polygon.length; i++) {
		    var polygonLine = [polygon[i], polygon[(i+1) % polygon.length]];
		    var result = intersectionLines(pointVerticalLine, polygonLine);

		    if (result.onLine2) {
		        if (pointsEqual(point, result)) {
		            return !onBorderCountsAsOutside;
		        }

		        if (result.y > point.y) {
		            higherIntersectionsCount++;
		        } else {
		            lowerIntersectionCount++;
		        }
		    }
		}  
	    if (higherIntersectionsCount % 2 != 0 && lowerIntersectionCount % 2 != 0) {
	        return true;
	    } else {
	        return false;
	    }
	}

	function intersectionLines(line1, line2, excludeStartingPoints, includeEndingPoints) {
	    return checkLineIntersection(line1[0].x, line1[0].y, line1[1].x, line1[1].y, line2[0].x, line2[0].y, line2[1].x, line2[1].y, excludeStartingPoints, includeEndingPoints);
	}



	/**
	Credits to: http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
	example:
	 returns {
	    x : 12,
	    y : 16,
	    onLine1 : false,
	    onLine2 : true
	 }
	*/
	function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY, excludeStartingPoints, includeEndingPoints) {
	    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
	    var denominator, a, b, numerator1, numerator2, result = {
	        x: null,
	        y: null,
	        onLine1: false,
	        onLine2: false
	    };
	    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
	    if (denominator == 0) {
	        return result;
	    }
	    a = line1StartY - line2StartY;
	    b = line1StartX - line2StartX;
	    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
	    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
	    a = numerator1 / denominator;
	    b = numerator2 / denominator;

	    // if we cast these lines infinitely in both directions, they intersect here:
	    result.x = line1StartX + (a * (line1EndX - line1StartX));
	    result.y = line1StartY + (a * (line1EndY - line1StartY));
	    /*
	            // it is worth noting that this should be the same as:
	            x = line2StartX + (b * (line2EndX - line2StartX));
	            y = line2StartX + (b * (line2EndY - line2StartY));
	            */
	    
	    // if line1 is a segment and line2 is infinite, they intersect if:
	    if (!excludeStartingPoints && numbersEqual(a,0)) {
	        result.onLine1 = true;
	    }
	    if (includeEndingPoints && numbersEqual(a, 1)) {
	        result.onLine1 = true;
	    }
	    if (firstGreaterThanSecond(a,0) && firstLessThanSecond(a,1)) {
	        result.onLine1 = true;
	    }
	    
	    // if line2 is a segment and line1 is infinite, they intersect if:
	    if (!excludeStartingPoints && numbersEqual(b, 0)) {
	        result.onLine2 = true;
	    }
	    if (includeEndingPoints && numbersEqual(b, 1)) {
	        result.onLine2 = true;
	    }
	    if (firstGreaterThanSecond(b, 0) && firstLessThanSecond(b, 1)) {
	        result.onLine2 = true;
	    }
	    // if line1 and line2 are segments, they intersect if both of the above are true
	    return result;
	};

	function isPointLeftOfLine(point, line) {
	    var linePoint1 = line[0];
	    var linePoint2 = line[1];
	    return ((linePoint2.x - linePoint1.x)*(point.y - linePoint1.y) - (linePoint2.y - linePoint1.y)*(point.x - linePoint1.x)) > 0;
	}

	function pointsEqual(point1, point2) {
	    if (!point1)
	        return false;
	    if (!point2)
	        return false;
	    // return point1.x == point2.x && point1.y == point2.y;
	    return numbersEqual(pointsDistance(point1, point2), 0);
	}

	function numbersEqual(num1, num2) {
	    return Math.abs(num2 - num1) < 1e-14;
	}

	function firstGreaterThanSecond(a,b) {
	    return !numbersEqual(a, b) && a > b;
	}

	function firstLessThanSecond(a, b) {
	    return !numbersEqual(a, b) && a < b;
	}

	function pointsDistance(point1, point2) {
	    return Math.pow(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2), 0.5);
	}

	function cloneObject(object) {
	    return extend({}, object);
	}
	

	function extend(target, source) {
		target = target || {};
		for ( var prop in source) {
			if (typeof source[prop] === 'object') {
				target[prop] = extend(target[prop], source[prop]);
			} else {
				target[prop] = source[prop];
			}
		}
		return target;
	}

	function filterFirstMatchingElement(array, fn) {
	    var element = array.filter(fn)[0];
	    return element;
	}

	function indexElementMatchingFunction(array, fn) {
	    var element = filterFirstMatchingElement(array, fn);
	    return array.indexOf(element);
	}

